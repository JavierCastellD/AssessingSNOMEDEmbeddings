import faiss
import numpy as np

from .embedding_models.embedding_model import EmbeddingModel
from .snomed import Snomed

class SnomedEmbedder:
    """Class that performs operations on SNOMED CT using embeddings.

    Attributes:
        snomed (Snomed):
            Snomed object that contains the information about SNOMED CT.
        
        embedding_model (EmbeddingModel):
            Embedding model used for generating embeddings of each concept.
    
        embedding_values (list):
            List of embeddings, one per each SNOMED CT concept. The embedding at position i corresponds to the concept denoted by the ID
            at position i in embedding_sct_index.
        
        embedding_sct_index (list):
            List of SNOMED CT concept IDs.
    """
    def __init__(self, snomed : Snomed, embedding_model : EmbeddingModel, embedding_dictionary : dict = None):
        """Prepares the class by storing the SNOMED CT model, the embedding model, and prepares the dictionary needed 
        for some of the functionality. If no dictionary is given to the concept, one is generated by iterating over
        the concepts, obtaining their descriptions and creating the embedding for a concept as an average of the embedding of
        the descriptions.
        
        Parameters:
            snomed (Snomed):
                Snomed object that contains the information about SNOMED CT.
            embedding_model (EmbeddingModel):
                Represents an embedding model.
            embedding_dictionary (dict):
                Dictionary whose keys are IDs of SNOMED CT concepts and the values are their corresponding embeddings.
        
        """
        
        self.snomed = snomed
        self.embedding_model = embedding_model

        # If no embedding dictionary for SNOMED CT was given, we create our own
        if embedding_dictionary is None:
            embedding_dictionary = dict()

            for conceptID in snomed.get_sct_concepts(metadata=False):
                descriptions = snomed.get_descriptions(conceptID)
                
                embedding_dictionary[conceptID] = embedding_model.get_embedding_from_list(descriptions)
        
        # We keep a list of the embeddings of each SNOMED CT concept, as well as a list with their corresponding IDs
        self.embedding_values = list(embedding_dictionary.values())
        self.embedding_sct_index = list(embedding_dictionary.keys())

        # We use Faiss for fast similarity search, so we need to normalize the embeddings first
        faiss_embeddings = np.array(self.embedding_values).astype(np.float32)
        faiss.normalize_L2(faiss_embeddings)

        # Because we want to use cosine similarity, we need to define the metric as inner product
        self.faiss_index = faiss.index_factory(200, "Flat", faiss.METRIC_INNER_PRODUCT)
        self.faiss_index.ntotal

        self.faiss_index.add(faiss_embeddings)

    
    def get_most_similar_concept(self, word : str, n : int = 1):
        '''Method that returns the most similar concept to the string that receives as a parameter. This is
        done by performing cosine similarity between embeddings.
        
        Paramters:
            word (str):
                String of text from which to obtain the most similar concept.
            n (int):
                Number of similar concepts to retrieve. The default value is 1.
        Returns:
            A tuple (SCT-ID, sim_value), where the first element is the ID of the SNOMED concept, and the second
            is the similarity score. If n is greater than 1, it returns a list of tuples with the n most similar 
            concepts instead. If no embedding model was assigned, an empty list is returned.
        '''
        vector = self.model.get_embedding(word)

        # Normalize the vector
        q_vector = np.array([vector]).astype(np.float32)
        faiss.normalize_L2(q_vector)

        # Perform the search
        sim_values, index = self.faiss_index.search(q_vector, n)

        # Return a tuple (conceptID, similarity)
        if n <= 1:
            concept_id = self.embedding_sct_index[index[0][0]]
            return (concept_id, sim_values[0][0])
        else:
            sim_list = [(sim_val, i) for sim_val, i in zip(sim_values[0], index[0])]
            return sim_list
        
    
    def get_postcoordinated_expression(self, clinical_term : str):
        pass

    def identify_semantic_type(self, clinical_term : str):
        pass

    def identify_reference_concept(self, clinical_term : str, semantic_type : str):
        pass

    def identify_target_concept(self, clinical_term : str, reference_concept : str, relationID : int):
        pass